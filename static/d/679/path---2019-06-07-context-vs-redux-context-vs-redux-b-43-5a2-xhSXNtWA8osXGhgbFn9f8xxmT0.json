{"data":{"site":{"siteMetadata":{"title":"brain's base","author":"Jeff Chheng"}},"markdownRemark":{"id":"1324a175-4a7e-5c0a-b0a9-615a0c43bf79","excerpt":"=====• Docs/Guidelines+Examples on best practice for:\n• +When to use Redux\n• +When to use LocalState\n• +How to use localstate only\n• +How to use data-driven…","html":"<p>=====</p>\n<p>• Docs/Guidelines+Examples on best practice for:\n• +When to use Redux\n• +When to use LocalState\n• +How to use localstate only\n• +How to use data-driven local state\n• +How to use data-driven redux state\n• +How to get debugger features from local state\n• PoC on useDebugger</p>\n<h1>Best practice for Redux in Enterprise apps</h1>\n<h2>What's the TL;DR?</h2>\n<p>Questions to ask when using hooks:\nDo I want to load some data and forget about it? Check out <a href=\"https://github.com/konciergeMD/atlas-engage/blob/develop/src/common/utils/useFetch.js\">useFetch</a> + <a href=\"https://reactjs.org/docs/hooks-reference.html#usecontext\">useContext</a> (optional).\nDo I want that data to show up in debug dumps? Check out <a href=\"https://github.com/konciergeMD/atlas-engage/pull/2369/files#diff-f72fccec2c4b421eaf263e007e96f6c3R25\">useDebugger</a>.\nTable/search data? Try out <a href=\"https://reactjs.org/docs/hooks-reference.html#usereducer\">useReducer</a> or <a href=\"https://reactjs.org/docs/hooks-reference.html#usestate\">useState</a>.\nForms or user input? useState/useReducer. <a href=\"https://twitter.com/acdlite/status/1045362245507506176\">Anything but Redux!</a></p>\n<p>Questions to ask when using Redux:\nShould this data be accessible by EVERY component, and does it update often (especially via websockets or PATCH operations)? <a href=\"https://redux.js.org/faq/general#when-should-i-use-redux\">Redux is your friend here.</a>\nDo updates depend on previous state (e.g., for optimistic updates or updating in general)? <a href=\"https://github.com/reduxjs/redux-thunk#motivation\">Redux + thunks!</a></p>\n<p>Also consider the complexity of debugging and <em>fixing</em> issues. Yes, Redux snapshots the state, but how many places are reading from state? Is the problem in the actions, the reducer, the loading component, the consuming component? Is it timing or clean-up issues? Compare this to hooks, where the problem can only occur in very obvious places, due to one-way data binding: the parent component that loads the data and provides the context/props, or the children consuming it.</p>\n<h2>A brief history of best practices</h2>\n<p>The world of web development is rapidly changing and innovating. Every year, best practices are evolving, and it can be hard to keep pace. I could go on and on about the evolution of jQuery to AngularJS to React, but I'll keep it relevant to enterprise React apps.</p>\n<p>In 2015, mixins were considered the best way to share logic between components, but <a href=\"https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html\">were eventually considered detrimental</a>.</p>\n<p>In 2016 (and until now), Redux was essentially the de facto standard for predictable state management.</p>\n<p>In 2018, React 16.3 came out with the new context API, but it was ahead of its time. It wasn't until 2019 that hooks provided an ergonomic way to use context (pun intended).</p>\n<h2>Redux vs. Hooks + Context</h2>\n<p>When starting an enterprise React app, the benefits of coupling it with Redux are well documented. You have time travel debugging, and global state to send in debug logs. These are very valuable for debugging enterprise apps in production. However, it comes with trade-offs as well that are also well documented. See <a href=\"https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367\">\"You might not need redux.\"</a></p>\n<p>To use Redux you have to do the following:\nDefine actions/action creators.\nDefine cases in one or more reducers to handle these actions.\nUse higher-order components like connect + a custom toJS if you are using ImmutableJS.\nYou must architecture components that can use arbitrary state at any time.\nAnd of course, you must test all this.</p>\n<p>This is in contrast to hooks + context that let you do the following:\nYou define a parent component that fetches data with a custom hook.\nYou can block rendering on failure, or provide a custom error <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">Symbol</a> that children can handle.\nUnidirectional data flow: children only have access to what their parents do--idiomatic React!</p>\n<p>With useFetch + useContext, you get reference equality. No unnecessary renders because data is fetched and set once. No HOCs to subscribe and convert data. It may be unfamiliar, but you get a simple API with little-to-no footguns.</p>\n<h2>When to use local state (for data loading)</h2>\n<p>Do you need to fetch and read some data with no mutations (that is, calling GET on the same endpoint generally returns the same result every time)? Then this might the perfect case for custom hooks and context (or just good ol' props).</p>\n<p>Introducing <code>useGetFetch</code>! Pass in a truthy URL, and it will attempt to fetch it, and return it in the form of <code>[data, isLoading]</code>. After that, it's up to you to handle loading states and verifying the data is what you want.</p>\n<p>Do you also want to save the data to a debug log? Introducing <code>useDebugger(key: string, data: any, shouldSave: boolean): void</code>! Pass in the key to identify the data in the debug log, the data you want to log, and a boolean representing whether it should be saved; for example, you may only want to save error messages. When a user opens the report problem modal, all components using <code>useDebugger</code> will report back their state to be included in the debug dump.</p>\n<h3>Examples with Hooks</h3>\n<p>Imagine a parent component that fetches person data and provides that data to its children:</p>\n<pre><code class=\"language-javascript\">// UserLoader.jsx\nexport const UserContext = React.createContext(null);\n\nexport function UserLoader({ userId }) {\n  const url = userId &#x26;&#x26; `/api/v1/users/${userId}`;\n  const [user, isLoading] = useGetFetch(url);\n  const isValid = user === null || user.id === userId);\n  useDebugger('UserLoader url: ' + url, user, !isValid);\n\n  if (user === null || isLoading) {\n    return &#x3C;LoadingIndicator />;\n  }\n\n  if (!isValid) {\n    return &#x3C;SomethingsGoneWrong />;\n  }\n\n  return (\n    &#x3C;UserContext.Provider value={user}>\n      {children}\n    &#x3C;/UserContext.Provider>\n  );\n}\n\n// Username.jsx\nimport { UserContext } from './UserLoader';\n\nexport function Username() {\n  const user = useContext(UserContext);\n  return &#x3C;div>{ user.username }&#x3C;/div>\n}\n</code></pre>\n<p>This is a simple case, but there could be other components consuming a UserConext, like an Avatar, FriendsLoader, etc. Having a top-level loader lets you handle data fetching and loading/error handling in one place. The children can focus on rendering. And it also lets you compose with other Loader-type components:</p>\n<pre><code class=\"language-javascript\">// userId could be coming from a router\nexport function User({ userId }) {\n  return (\n    &#x3C;UserLoader userId={userId}>\n      &#x3C;FriendsLoader>\n        {children}\n      &#x3C;/FriendsLoader>\n    &#x3C;/UserLoader>\n  );\n}\n</code></pre>\n<p>Maybe UserLoader blocks the entire UI if something goes wrong, but we can continue on if the FriendsLoader does not. As soon as this sub-tree is unmounted, the data is gone. Or if the route/ID changes, all effects are re-run and updated. No children can reference stale state!</p>\n<p>A FriendsList component could actually use the list of friend user IDs to provide an individual user context. The active user has access to the top-level UserLoader, and the children have access to the context provided by FriendsList+UserLoader:</p>\n<pre><code class=\"language-javascript\">export function FriendsList() {\n  const friends = useContext(FriendsContext);\n  return friends.map(({ userId }) => {\n    &#x3C;UserLoader key={ userId } userId={ userId }>\n      &#x3C;Username />\n    &#x3C;/UserLoader>\n  });\n}\n</code></pre>\n<p>These are simple cases that could also use props if multiple, deeply-nested components don't need to reference the same piece of data.</p>\n<p>Here's an example of using search and paging with useReducer + useFetch. Imagine something like the emoji table at Slack.</p>\n<pre><code class=\"language-javascript\">const PAGE_SIZE = 50;\n\nconst initialState = {\n  page: 1,\n  offset: 0\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'pageUp': return {\n      page: state.page + 1,\n      offset: state.offset + PAGE_SIZE\n    };\n    case 'pageDown': return {\n      page: state.page - 1,\n      offset: state.offset - PAGE_SIZE\n    };\n    case 'selectPage': return {\n      page: action.page,\n      offset: action.page * (PAGE_SIZE - 1)\n    }\n    case 'reset': return initialState;\n    default: throw new Error('invalid action.type provided', action.type):\n  }\n}\n\nexport function EmojiTable() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const [data] = useFetch(`/api/v1/emojis/accolade-inc?offset=${state.offset}&#x26;size=${PAGE_SIZE}`);\n\n  if (data === null ) {\n    return &#x3C;LoadingIndicator />;\n  }\n\n  if (!Array.isArray(data)) {\n    return &#x3C;SomethingsGoneWrong />;\n  }\n\n  return (\n    &#x3C;GenericTable\n      tableSchema={ /* TODO */ }\n      data={ data }\n      currentPage={ state.page }\n      onPageSelect={ page => dispatch({ type: 'selectPage', page }) }\n      pageUp={ () => dispatch({ type: 'pageUp' }) }\n      pageDown={ () => dispatch({ type: 'pageDown' }) }\n      reset={ () => dispatch({ type: 'reset' })} />\n  );\n}\n</code></pre>\n<p>Yay for colocated state and components! No HOCs, no middlewares, no thunks, no combining reducers, no boilerplate. This could've also been recreated with useState, but useReducer is ideal for pieces of state that need to change together or depend on previous state.</p>\n<h2>When to use Redux</h2>\n<p>Do you need to provide truly global data that needs to be updated in a predictable manner? Then Redux is an excellent choice!</p>\n<p>See Encounters, Activities, Communications, and Messaging where WebSockets or direct subscriptions mutate the data without user intervention, and the user should have access to this data on all views. These pieces of data don't belong to any component or sub-tree lifecycle.</p>\n<p>As an example, perhaps a communication update comes in via websockets or as a responseAction to a PATCH. This isn't <em>exactly</em> how it works now, but this would be the general heuristic for using Redux:</p>\n<h3>Examples with Redux</h3>\n<pre><code class=\"language-javascript\">const COMMUNICATION_UPDATE = 'COMMUNICATION_UPDATE';\n\n// on new communication WS message or successful PATCH\ndispatch({\n  type: COMMUNICATION_UPDATE,\n  payload: communication\n});\n\n// this needs to mutate one or more pieces of state\nexport function communicationsReducer(state = initialState, { type, payload }) {\n  switch (type) {\n    case COMMUNICATION_UPDATE: {\n      // if comm was linked, decided not to link, or was reassigned\n      if (\n        payload.about.length >= 1\n        || payload.willNotLink\n        || didPractitionerChange(payload, state[payload.id])\n      ) {\n        const nextState = { ...state };\n        delete nextState[payload.id];\n        return nextState;\n      }\n      return { ...state, [payload.id]: payload };\n    }\n    // other cases\n    default: return state;\n  }\n}\n\nexport function encountersReducer(state = initialState, { type, payload }) {\n  switch (type) {\n    case COMMUNICATION_UPDATE: {\n      const linkedEncounterIds = payload.about.map(x => x.reference.split('/').pop());\n      const nextState = { ...state };\n      // Pretend there's some complicated code here to:\n      // - Remove the communication from encounters that are no longer linked\n      // - Add the communication to encounters where it is now linked\n      // - Update the communication in-place for still-linked encounters\n      return nextState;\n    }\n    // other cases\n    default: return state;\n  }\n}\n</code></pre>\n<p>These top-level pieces of state are being used across the app with complicated update logic that may depend on other parts of global state are the perfect candidates to store in Redux. Activities that are collected in one place but also filtered into view models are another excellent example.</p>\n<p>It is totally possible to replicate this same behavior with useReducer, but at that point, you would've recreated Redux without middlewares (which may be fine for a small/medium-sized app).</p>\n<h2>Conclusion</h2>\n<p>Thanks for reading. <a href=\"#whats-the-tldr\">See the TL;DR at the top.</a></p>","frontmatter":{"title":"","date":null,"description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-06-07-context-vs-redux/context-vs-redux/","previous":{"fields":{"slug":"/2019-06-07-context-vs-redux/"},"frontmatter":{"title":"Hooks + Context vs. (React-)Redux"}},"next":null}}
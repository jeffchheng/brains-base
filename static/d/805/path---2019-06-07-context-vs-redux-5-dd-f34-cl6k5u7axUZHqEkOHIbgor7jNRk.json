{"data":{"site":{"siteMetadata":{"title":"brain's base","author":"Jeff Chheng"}},"markdownRemark":{"id":"5acef7c8-4de1-5de0-8865-4c646b5ac113","excerpt":"With hooks, a lot of people are asking if Redux is dead. The answer is \"no.\"For an enterprise web app, I'd argue it's probably a forgone conclusion it will beâ€¦","html":"<p>With hooks, a lot of people are asking if Redux is dead. <a href=\"https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/\">The answer is \"no.\"</a></p>\n<p>For an enterprise web app, I'd argue it's probably a forgone conclusion it will be used in <em>some</em> capacity. Time travel debugging and capturing your entire app state to send in a debug log are the two biggest arguments for production apps to use Redux. Users might not give reliable repro steps, so your action log becomes your repro steps. Users might not accurately describe what they see, or it might be hidden, so a state snapshot let's you inspect the data directly. It is also very testable, predictable, and so on. Despite these benefits, it absolutely shouldn't be used for everything.</p>\n<p>Consider the boilerplate and developer overhead needed to create a reducers, actions/action creators, combining said reducers, connecting to the store, and using a higher-order component, and so on. Think about all the unit tests required to prove correctness. Granted, there's <a href=\"https://redux-starter-kit.js.org/introduction/quick-start\">Redux Starter Kit</a> nowadays.</p>\n<p>This isn't even to mention redux-thunk and additional middlewares. Middlewares are certainly elegant, but can be difficult to reason about like dream levels in <em>Inception</em>.</p>\n<h2>Here comes our lords and saviors, the Hooks and new Context API</h2>\n<p>Before hooks, I'd say the context API was super clunky to use and generally not worth it. <a href=\"https://reactjs.org/docs/context.html#consuming-multiple-contexts\">Consuming multiple contexts looked horrendous with render props.</a></p>\n<pre><code class=\"language-javascript\">&#x3C;ContextA.Consumer>\n  {valueA => (\n    &#x3C;ContextB.Consumer>\n      {valueB => (\n        &#x3C;Component valueA={valueA} valueB={valueB} />\n      )}\n    &#x3C;/ContextB.Consumer>\n  )}\n&#x3C;ContextA.Consumer>\n</code></pre>\n<p><code>useContext</code> now makes it so ergonomic.</p>\n<pre><code class=\"language-javascript\">const valueA = useContext(ContextA);\nconst valueB = useContext(ContextB);\n</code></pre>\n<p>Just... <em>chef's kiss</em>.</p>\n<p>Take this <code>useFetch</code> hook for example. Assume we're only doing GETs for simplicity. (Using something else like PATCH may be indicative of a valid use for Redux: predictable and/or optimistic updating.)</p>\n<pre><code class=\"language-javascript\">export function useFetch(url) {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    let shouldRun = true;\n\n    if (url) {\n      fetch(url)\n        .then(response => response.json())\n        .then(data => shouldRun &#x26;&#x26; setData(data))\n        .catch(error => shouldRun &#x26;&#x26; setData(error);\n    }\n\n    // When the URL changes or the component is unmounted,\n    // do not attempt to set state.\n    return () => { shouldRun = false; };\n  }, [url]);\n\n  return data;\n}\n</code></pre>\n<pre><code class=\"language-javascript\">// Hooks + Context implementation.\n\nexport const UhOh = {};\n\nexport function UserWrapper({ id }) {\n  const user = useFetch(id &#x26;&#x26; `/api/v1/users/${id}`);\n\n  // null means loading\n  if (user === null) {\n    return &#x3C;div>Loading...&#x3C;/div>;\n  }\n\n  // do some error checking\n  if (user.id !== id) {\n    return &#x3C;User.Provider value={UhOh}>{children}&#x3C;/User.Provider>;\n    // or just block rendering\n    // return &#x3C;div>Something went wrong!&#x3C;/div>;\n  }\n\n  // render a provider + children\n  return &#x3C;User.Provider value={user}>{children}&#x3C;/User.Provider>;\n}\n\nexport function Username() {\n  const user = useContext(User);\n  if (user === UhOh) {\n    return &#x3C;MissingData />;\n  }\n  return &#x3C;div>{user.username}&#x3C;/div>;\n}\n</code></pre>\n<p>Given the above, we're finally back to unidirectional data flow. <code>&#x3C;UserWrapper /></code> will load the data it's responsible for and ensure it is available to use. Of course, you might not need context in this case. It can just be a prop you pass. But imagine having multiple pieces of data you just want to set and forget and how easy this becomes to use.</p>\n<p>This is in contrast to the Redux implementation that requires you to load to the data and set it in state. But children (or maybe adjacent nodes) can access the store before the data is there, so you'll end up having to do a lot of defensive coding in your child components. You can attempt to recreate some of the same enforcements, but it ends up not being as granular or ergonomic.</p>\n<pre><code class=\"language-javascript\"></code></pre>","frontmatter":{"title":"Hooks + Context vs. (React-)Redux","date":"June 07, 2019","description":"The battle of the century for developer mindshare!"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-06-07-context-vs-redux/","previous":{"fields":{"slug":"/2019-06-06-react-best-practices/"},"frontmatter":{"title":"React best practices"}},"next":null}}
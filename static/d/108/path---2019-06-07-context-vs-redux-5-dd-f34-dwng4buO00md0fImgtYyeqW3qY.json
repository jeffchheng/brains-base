{"data":{"site":{"siteMetadata":{"title":"brain's base","author":"Jeff Chheng"}},"markdownRemark":{"id":"5acef7c8-4de1-5de0-8865-4c646b5ac113","excerpt":"With hooks, a lot of people are asking if Redux is dead. The answer is \"no.\"For an enterprise web app, I'd argue it's probably a forgone conclusion it will beâ€¦","html":"<p>With hooks, a lot of people are asking if Redux is dead. <a href=\"https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/\">The answer is \"no.\"</a></p>\n<p>For an enterprise web app, I'd argue it's probably a forgone conclusion it will be used in <em>some</em> capacity. Time travel debugging and capturing your entire app state to send in a debug log are the two biggest arguments for production apps to use Redux. Users might not give reliable repro steps, so your action log becomes your repro steps. Users might not accurately describe what they see, or it might be hidden, so a state snapshot let's you inspect the data directly. It is also very testable, predictable, and so on. Despite these benefits, it absolutely shouldn't be used for everything.</p>\n<p>Consider the boilerplate and developer overhead needed to create a reducers, actions/action creators, combining said reducers, connecting to the store, and using a higher-order component, and so on. Think about all the unit tests required to prove correctness. Granted, there's <a href=\"https://redux-starter-kit.js.org/introduction/quick-start\">Redux Starter Kit</a> nowadays.</p>\n<p>This isn't even to mention redux-thunk and additional middlewares. Middlewares are certainly elegant, but can be difficult to reason about like dream levels in <em>Inception</em>.</p>\n<h2>Here comes our lords and saviors, the Hooks and new Context API</h2>\n<p>Before hooks, I'd say the context API was super clunky to use and generally not worth it. <a href=\"https://reactjs.org/docs/context.html#consuming-multiple-contexts\">Consuming multiple contexts looked horrendous with render props.</a></p>\n<pre><code class=\"language-javascript\">&#x3C;ContextA.Consumer>\n  {valueA => (\n    &#x3C;ContextB.Consumer>\n      {valueB => (\n        &#x3C;Component valueA={valueA} valueB={valueB} />\n      )}\n    &#x3C;/ContextB.Consumer>\n  )}\n&#x3C;ContextA.Consumer>\n</code></pre>\n<p><code>useContext</code> now makes it so ergonomic.</p>\n<pre><code class=\"language-javascript\">const valueA = useContext(ContextA);\nconst valueB = useContext(ContextB);\n</code></pre>\n<p>Just... <em>chef's kiss</em>.</p>\n<p>Take this <code>useFetch</code> hook for example. Assume we're only doing GETs for simplicity. (Using something else like PATCH may be indicative of a valid use for Redux: predictable and/or optimistic updating.)</p>\n<pre><code class=\"language-javascript\">export function useFetch(url) {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    let shouldRun = true;\n\n    if (url) {\n      fetch(url)\n        .then(response => response.json())\n        .then(data => shouldRun &#x26;&#x26; setData(data))\n        .catch(error => shouldRun &#x26;&#x26; setData(error);\n    }\n\n    // When the URL changes or the component is unmounted,\n    // do not attempt to set state.\n    return () => { shouldRun = false; };\n  }, [url]);\n\n  return data;\n}\n</code></pre>\n<pre><code class=\"language-javascript\">// Hooks + Context implementation.\n\n// Reference to some common error object\nexport const UhOh = {};\n\nexport function UserWrapper({ id }) {\n  const user = useFetch(id &#x26;&#x26; `/api/v1/users/${id}`);\n\n  // null means loading\n  if (user === null) {\n    return &#x3C;div>Loading...&#x3C;/div>;\n  }\n\n  // render a provider + children\n  // you can even render a fallback here instead of passing bad data if it's not\n  // app-critical\n  return &#x3C;User.Provider value={user.id === id ? user : UhOh}>{children}&#x3C;/User.Provider>;\n}\n\nexport function Username() {\n  const user = useContext(User);\n  if (user === UhOh) {\n    return &#x3C;MissingData />; // or even null/false?\n  }\n  return &#x3C;div>{user.username}&#x3C;/div>;\n}\n</code></pre>\n<p>Given the above, we're finally back to unidirectional data flow. <code>&#x3C;UserWrapper /></code> will load the data it's responsible for and ensure it is available to use. Of course, you might not need context in this case. It can just be a prop you pass. But imagine having multiple pieces of data you just want to set and forget and how easy this becomes to use. You have contexts that allow errors to go through, or you can block an entire section of UI on erroneous data.</p>\n<p>No higher-order components (react-redux's connect, or your own Immutable-converting HOC). No props drilling. Only JavaScript and React primitives.</p>\n<p>This is in contrast to the Redux implementation that requires you to load to the data and set it in state. But children (or maybe adjacent nodes) can access the store before the data is there, so you'll end up having to do a lot of defensive coding in your child components. You can attempt to recreate some of the same enforcements, but it ends up not being as granular or ergonomic.</p>\n<pre><code class=\"language-javascript\">export const UhOh = {};\n\nexport function reducer(state = null, action) {\n  switch (action.type) {\n    case 'set': return action.payload;\n    case 'clear': return null;\n    default: return state;\n  }\n}\n\nexport function loadUser(id) {\n  return (dispatch) => {\n    fetch(`/api/v1/users/${id}`)\n      .then(response => response.json())\n      .then(data => dispatch({ type: 'set', payload: data }))\n      .catch(error => {\n        dispatch({ type: 'error', location: 'loadUser', payload: data });\n        dispatch({ type: 'set', payload: UhOh });\n      });\n  }\n}\n\nexport function clearUser() {\n  return { type: 'clear' };\n}\n\nexport function UserLoader({ id, dispatch }) {\n  useEffect(() => {\n    dispatch(loadUser(id));\n    return () => dispatch(clearUser());\n  }, [id, dispatch]);\n\n  return null;\n}\n\nexport function Username({ user }) {\n  if (user === UhOh) {\n    return &#x3C;MissingData />; // or even null/false?\n  }\n  return &#x3C;div>{user.username}&#x3C;/div>;\n}\n\n// Any component can subscribe to this value regardless of whether UserLoader has actually been rendered\n// and loaded data.\n// You may also need a `|> toJS` if you're using Immutable.\nexport const ConnectedUsername = Username |> connect(state => ({ user: state.user }));\n</code></pre>\n<p>This breaks one-way data flow. You can put <code>&#x3C;UserLoader /></code> where you think it's needed, but any component can s state. You can no longer reliably stop components from rendering something if they shouldn't, and thus it leads to more architecture overhead.</p>\n<p>Context or props passing just doesn't give you the same footgun. Children can only consume contexts their parents provide (or a default value).</p>","frontmatter":{"title":"Hooks + Context vs. (React-)Redux","date":"June 07, 2019","description":"The battle of the century for developer mindshare!"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019-06-07-context-vs-redux/","previous":{"fields":{"slug":"/2019-06-06-react-best-practices/"},"frontmatter":{"title":"React best practices"}},"next":{"fields":{"slug":"/2019-06-07-context-vs-redux/context-vs-redux/"},"frontmatter":{"title":""}}}}